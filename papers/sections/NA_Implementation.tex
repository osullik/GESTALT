\section{Implementation}
\label{section:implementation}

The implementation section of this report discusses the engineering work conducted so far to implement the \textit{GESTALT} architecture and reviews high-level results. Specific experimental results are in section \ref{section:results}.

\subsection{Data Collection}
Due to the complexity of the task and significant concurrent work in the area, the development of automated object detection and geolocation was scoped out. 
Instead, the author developed a small dataset manually, as discussed in section \ref{section:dataset}. 
%The data extraction, cleaning and loading are implemented in Python in two parts, the \textit{KML parser} for object extraction and the \textit{Open Street Maps} query interface for location retrieval. 
%The KML parser leverages the \textit{fastKML}\footnote{\href{https://pypi.org/project/fastkml/}{Fast KML PyPI Repo}} and ingests a KML file divided by region (where each region is a bounding box covering an arbitrary number of locations). 
%Within each region (for this test dataset), each location is separated, with its objects stored as its children. 
%Attributes of the objects (e.g. colour, size, material) are recorded in the comments field as key:value pairs.
%The KML Parser extracts the objects into dictionaries organised by location before exporting the files as JSON for future analysis. 

%The OSM query interface leverages the \textit{OSMPythonTools}\footnote{\href{https://pypi.org/project/OSMPythonTools/}{OSMPythonTools PyPI Repo}}. It passes a bounding box to the OSM Overpass-Turbo API\footnote{\href{https://overpass-turbo.eu/}{Overpass-Turbo API}} and requests the relevant location nodes in the area. 
%The results are arranged into a dictionary and exported as JSON for further analysis. 

Implemented so far is the translation from inputs of objects and locations, in different formats, to a standard JSON format. Not yet implemented is the automatic detection and geolocation of objects. 

%\subsection{Ownership Assignment}
%Ownership assignment is implemented in Python in two ways. The first is the trivial implementation, where the location returned from the OSM query is a bounding polygon. 
%In this case, if the point lies within the minimal enclosing rectangle of the polygon, it is added as a 'member' of that location. 
%The second, more common (and more challenging approach) formulates an unsupervised learning problem using clustering libraries from \textit{scikit-learn}\footnote{\href{https://pypi.org/project/scikit-learn/}{Scikit-Learn PyPI Repo}}. 
%Given a collection of objects and a collection of locations within a bounding box region, clustering assigns each object to its 'parent' location. 
%Under the assumption that the number of locations equals the number of clusters, K-Means clustering proved to be the most effective approach. 
%After clustering the objects, we determine the centroid of the object cluster. Given a KD tree constructed from location point coordinates, a nearest neighbor search on the KD tree with a query parameter of the object centroid yields the nearest location and is assigned ownership of that cluster
%A detailed performance comparison is in section \ref{section:results}. 

%Overall, initial proof-of-concept clustering uses K-Means and DBSCAN clustering. An optimal solution to the ownership assignment problem is an exciting and unusual clustering problem. 
%Assuming that the collection of locations is complete and that the point coordinate of the location is central to the collection of objects that belong to that location, the clustering problem is the assignment of an arbitrary number of objects to any of a set of possible centroids. Not every centroid will have objects, and objects are not uniformly distributed. Initial investigation into the DVBSCAN algorithm Ram et al. proposed in 2010 presents a promising direction to resolve this problem.\cite{Ram2010} 

%Overall, the Ownership Assignment process needs to produce a data structure that will permit set membership checking for search and set the conditions for the concept mapping process. It is the most complete component of \textit{GESTALT}. The choice of clustering algorithm needs refinement, and location-based bloom filters need to be implemented to support efficient search, but it is otherwise functional. 


%\subsection{Concept Mapping}
%Concept mapping has been partially implemented in Python leveraging the \textit{Scipy} library\footnote{\href{https://pypi.org/project/scipy/}{SciPy PyPI Repo}}. Two different approaches have been trialled. 
%The first is simple dynamic arithmetic on the coordinates stored in a Pandas data frame. If one set of coordinates is above, below, left or right of another, it is north, south, east or west, respectively. 
%While these calculations are in constant time for straightforward comparisons of known objects (e.g. "is the pond west of the bridge"), the time complexity rapidly increases as soon as aggregations are employed. 
%Queries of "Give me everything west of the duck pond" would execute in $O(N)$ time as each element has to be examined. Worst-case queries would run in $O(N\sup{2})$ time, where every object is checked for its position relative to every other object. 

%The second (better) approach (only partially implemented) instantiates the objects within a location into a KD-Tree. 
%Assuming that the object centroid is the root, we can quickly complete queries like "Give me everything west of the duck pond" by leveraging the structure of the subtrees to return the requested set. 
%Similarly, getting the relative positions of two objects searches for a common ancestor. It uses the path between the children and their ancestor node to infer their spatial relation to each other.

%A third approach, designed to leverage the \textit{Neo4J Python Library}\footnote{\href{https://pypi.org/project/neo4j/}{Neo4J PyPI Repo}} to connect to a \textit{Neo4J Graph Database}\footnote{\href{https://neo4j.com/}{Neo4J Website}} but not implemented frames concept mapping as a graph traversal problem. 
%In this formulation, each object is a node on a graph. Weighted, labelled edges exist between each node within a given proximity threshold to the node. 
%The edge labels describe the neighbouring node's cardinal direction and the distance weights. 
%After constructing the object graph, queries for 'give me everything west of the duck pond' would freely explore nodes connected by west, north and south edges. 
%It can only traverse along an east edge so long as the total cost of travelling east would be less than the cumulative value of the 'west' travel up to this point. 

%Overall, concept mapping aims to enable geographic search over objects by explicitly representing their geospatial relationships to each other. 
%The author implemented a very basic approach using coordinate arithmetic was quickly determined to be infeasible for the extensive data sets that \textit{GESTALT} anticipates processing. 
%KD-Trees for the objects in each location have been implemented, as have the KD-Trees for the locations themselves. 
%This conceptual KD-Tree of KD-Trees approach performs a natural aggregation function which, provided that regions are created consistently, will allow for relative spatial queries at different levels of granularity. 
%Empirical evaluation of the performance of the arithmetic, KD-Tree and Graph-based approaches is yet to be completed. 

%\subsection{Search}
%The search function has been implemented using the Python \textit{Pandas}\footnote{https://pypi.org/project/pandas/}{Pandas PyPI Repo} library. 
%This approach assumes a single data frame of objects and their determined locations because of the number of possible attributes an object can have and the relatively few that they possess, this is a sparse data structure. 
%The sparseness does indicate the discriminatory power of remembering attributes. For example, a 'door' is not informative, but a 'blue door' on your favourite seaside restaurant is more likely to prune the search space. 
%Because \textit{GESTALT} is designed only for the last-mile search and assumes a small starting region, it may remain feasible to use a simple data structure like a Pandas data frame containing all the objects for all the locations for the query region. 
%More work with the aggregation functions is required to determine if it can support all the necessary aggregation queries comparing object collections. 

%Semantic search has not been implemented. However, the Levenshtein string distance metric (with $threshold = 0.8$) checks for small spelling discrepancies in input words. The priority weights towards retrieving all possible objects, so we accept the increased risk of mistakenly including an object to move the recall closer to 100\%. The next component to be implemented is a nearest-neighbour retrieval mechanism using word embeddings. Prior work indicates that developing databases of embeddings is trivial\cite{Mueller2012}, but using existing datasets tools like word2vec, GloVe and fasttext can generate embeddings over large, publicly available corpora that can be recreated. 

%As discussed in the subsection on Ownership Assignment implementation, bloom filters are a much more efficient operator for set membership testing. 
%The KD-Tree is more suited for geospatial queries, so the Pandas Dataframe currently supports the gaps between the two in supporting aggregation queries. More work is required to integrate these data structures into a coherent search pipeline that maximises recall while actively pruning the search space at every step so that the searcher can find their locations of interest. Natural language querying is an active area of research yet to present a solution capable of effectively translating natural language queries and their SQL solutions. Given the relatively constrained domain of this problem set, it is a good candidate for implementation as a low priority for improvement. 

%\subsection{Summary of Implemenation}
%The implementation of \textit{GESTALT} is incomplete, but initial work demonstrates its feasibility. The priority for future work is to implement concept mapping fully, add bloom filters to locations, and implement semantic similarity searching. Improving the query interface is another 'easy win'. The work that will unlock the 'real-world' potential of \textit{GESTALT} is the automation of object geolocation. Automating data collection is also the most challenging part of the problem and will require substantial work. 



% long version of fuzzy search saving here in case we want it

\begin{algorithm}
    \caption{Fuzzy Searching}\label{alg:fuzzySearchOLDs}
    \begin{algorithmic}
        \State{\textit{\textbf{QT} a list of query terms to search for}}
        \State{\textit{\textbf{II} an inverted index with objects as keys and locations as values}}
        \State{- - - - -}
        \Procedure{fuzzySearch}{$QT$,$II$}
            \State{$S$= \textbf{II.search}($QT$)} \Comment{\textbf{i}ncremental \textbf{q}uery \textbf{l}ist}
            \If{$S$ is Empty}
                \State{$iql$ = []}\Comment{An list to build with query terms}
                \While{$S$ is Empty}
                    \State{$dqt$ = Rarest object from $S$ in $II$}
                    \State{Append $dqt$ to $iql$}
                    \State{$S$= \textbf{II.search}($iql$)}
                    \If{$S$ > 0}
                        \State{Continue in loop}
                    \Else
                        \State{Pop $q$}
                        \State{$S$= \textbf{II.search}($iql$)}
                        \State{Break from Loop}
                    \EndIf
                \EndWhile
                \If{$S$ has more than 1 item}
                    \State{$S$ = \textbf{$II$.Rank($S$,$Q$)}}
                \EndIf
                \State{\textbf{return} $S$,$q$}
            \Else
                \State{\textbf{return} $S$}
            \EndIf
        \EndProcedure
        \Procedure{Rank}{$S$,$q$,$II$}\Comment{$S$ results from $q$ query terms in $II$}
            \State{$LR$ = Empty Ordered Dictionary}\Comment{\textbf{L}ocation \textbf{R}ank}

            \For{Each $L$ in $S$}\Comment{\textbf{L}ocation}
                \State{$p$ = 1}\Comment{Probability location correct}
                \For{$O$ in $q$}
                    \State{$OP$ = Prob of Obj@Locin $II$}\Comment{\textbf{O}bject \textbf{P}robability}
                    \State{$P$ = $P$x$OP$}
                \EndFor
                \State{$LR$[$L$] = $P$}
            \EndFor
            \State{\textbf{return}$LR$ ordered most to least likely}
            \EndProcedure
    \end{algorithmic}
\end{algorithm}