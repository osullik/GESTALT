\section{Concept Mapping}
\label{section:concept}

\subsection{Problem Definition}
Overall, concept mapping aims to enable geographic search over objects by explicitly representing their geospatial relationships to each other. 

- motivation for pruning...........



\subsubsection{Object-object relations}
- description..............
- diagram showing input and expected output............

\paragraph{Query Input}
- algorithm for parsing from grid, etc.


\begin{algorithm}
    \caption{Creating a Concept Map}\label{alg:geoToGrid}
    \begin{algorithmic}
        \State{\textit{\textbf{T} a Location Table with ID, Name, Lat \& Long of its objects}}
        \State{- - - - -}
        \Procedure{createConceptMap}{$T$}

            \State{LonList = []} \Comment{A list}
            \State{LatList = []} \Comment{A list}
            \State{$M$ = [[][]]} \Comment{A matrix of 0s}
        
            \State{Sort rows from North to South}
            
            \For{$R$ in $T$} \Comment{Where $R$ is a Row}     
                \State{Add R.$ID$ to $LatList$} \Comment{$R.ID$ is the obj unique ID}
            \EndFor
            
            \State{Sort rows from West to East}
            
            \For{$R$ in $T$} 
                \State{Add R.$ID$ to $LonList$}
            \EndFor
            
            \For{$ID$ in $Lonlist$}          
                \State{get index of $ID$ in $LonList$ as $i$}
                \State{get index of $ID$ in $LatList$ as $j$}               
                \State{$M$[$i$][$j$] = $ID.Name$} \Comment{Name of object with $ID$}
            \EndFor
            
            \State{\textbf{return} $M$} \Comment{Having $[0,0]$ as NW corner}

        \EndProcedure


    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Ordering the Search Terms}
    \begin{algorithmic}
        \State{\textit{\textbf{M} A ConceptMap Matrix with objects or 0s}}
        \State{- - - - -}
        \Procedure{Order Search Terms}{$M$}
            \If{$M$ has single Item}
                \State{Return $M$}
            \EndIf
            \State{$Traversed$ = []}
            \State{$R$, $C$ = Number of rows and columns}
            \State{$Rd$ = ($R$+$C$)-1}

            \For{$r$ in range $Rd$}
                \For{$i$ in range $r$+1}
                    \State{$j$ = $r$-$i$}
                    \If{$i$ < $R$ and $j$ < $C$}
                        \If{$M$[$i$][$j$] != 0}
                            \State{Add $M$[$i$][$j$] to $Traversed$}
                        \EndIf
                    \EndIf 
                \EndFor
            \EndFor
            \State{\textbf{return} $Traversed$}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\paragraph{Solution}

\begin{algorithm}
    \caption{Recursive Grid Search}\label{alg:gridSearch}
    \begin{algorithmic}
        \State{\textit{\textbf{M} A ConceptMap Matrix with objects or 0s; [0,0] is NW most point}}
        \State{\textit{\textbf{L} A NW to SE ordered list of objects to search for}}
        \State{\textit{\textbf{D} The direction of Pruning, 'northToSouth' or 'westToEast'}}
        \State{- - - - -}
        \Procedure{recursiveGridSearch}{$M$,$L$,$D$} %\Comment{$M$ a matrix of a Loc's objects, $L$ an ordered list of objects to search for, $D$ is the pruning direction}

            \If{$L$ has only 1 item}\Comment{Base Case}
                \If{pop($L$) in $M$}
                    \State{\textbf{return} $True$}              
                \Else
                    \State{\textbf{return} $False$}
                \EndIf            
            \EndIf


            \If{$D$ is $northToSouth$}
                \State{$NorthernObject$ = pop($L$)}                
                \If{$NorthernObject$ not in $M$}
                    \State{\textbf{return} $False$}               
                \EndIf

                \State{$M$ = Prune all objects north of $NorthernObject$}
                \State{\textbf{return} recursiveGridSearch($M$,$L$,$westToEast$)}
           
            \EndIf

            \If{$D$ is $eastToWest$}
                \State{$WesternObject$ = pop($L$)}
                
                \If{$WesternObject$ not in $M$}
                    \State{\textbf{return} $False$}
                \EndIf

                \State{$M$ = Prune all objects west of $WesternObject$}
                \State{\textbf{return} recursiveGridSearch($M$,$L$,$northToSouth$)}
            \EndIf

        \EndProcedure

    \end{algorithmic}

\end{algorithm}



- recursive algorithm for finding any match
- complexity analysis

\paragraph{Experimental Results?}
- on ground truth queries? report number of locations pruned? timings?




\subsubsection{Object-Location relations}
- description...........
- diagram showing input and expected output.........

\begin{algorithm}
    \caption{Generating Location Centric Structure}
    \begin{algorithmic}
        \State{\textit{\textbf{T} a Location Table with ID, Name, Lat \& Long of its objects}}
        \State{\textit{\textbf{X} a (x,y) tuple of the centroid for the location}}
        \State{- - - - -}
        \Procedure{MakeLocationCentricStructure}{$T$,$X$}
            \State{$Q$\{$NW$:[], $NE$:[], $SW$:[], $SE$:[]\}}\Comment{Dictionary}
            \For{$R$ in $T$}\Comment{R is a row describing a single object}
                \If{$R.y$ < $X.y$}
                    \If{$R.x$ <= $X.x$}
                        \State{Add $R.Name$ to $Q.SW$}
                    \Else
                        \State{Add $R.Name$ to $Q.SE$}
                    \EndIf
                \Else
                    \If{$R.x$ <= $X.x$} 
                        \State{Add $R.Name$ to $Q.NW$}
                    \Else
                        \State{Add $R.Name$ to $Q.NE$}
                    \EndIf
                \EndIf 
            \EndFor
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Querying Location Centric Structure}
    \begin{algorithmic}
        \State{\textit{\textbf{Q} a Dictionary of lists of objects of form: \{$NW$:[], $NE$:[], $SW$:[], $SE$:[]\}}}
        \State{\textit{\textbf{NS} a query Direction of "North\_of" or "South\_of"}}
        \State{\textit{\textbf{EW} a query Direction of "West\_of" or "East\_of"}}
        \State{\textit{\textbf{S} the name of an object to searc for}}
        \State{- - - - -}
        \Procedure{QueryLocationCentricStructure}{$T$,$X$}
            \If{$NS$ = $North_of$ and $EW$ = $None$}
                \If{$S$ in $Q.NW$ \textbf{OR} $Q.NE$}
                    \State{\textbf{return}$True$}
                \EndIf 
            \EndIf

            \If{$NS$ = $North\_of$ and $EW$ = $West\_of$}
                \If{$S$ in $Q.NW$}
                    \State{\textbf{return}$True$}
                \EndIf 
            \EndIf

            \If{$NS$ = $North\_of$ and $EW$ = $East\_of$}
                \If{$S$ in $Q.NE$}
                    \State{\textbf{return}$True$}
                \EndIf 
            \EndIf

            \If{$NS$ = $South\_of$ and $EW$ = $None$}
                \If{$S$ in $Q.SW$ \textbf{OR} $Q.SE$}
                    \State{\textbf{return}$True$}
                \EndIf 
            \EndIf

            \If{$NS$ = $South\_of$ and $EW$ = $West\_of$}
                \If{$S$ in $Q.SW$}
                    \State{\textbf{return}$True$}
                \EndIf 
            \EndIf

            \If{$NS$ = $South\_of$ and $EW$ = $East\_of$}
                \If{$S$ in $Q.SE$}
                    \State{\textbf{return}$True$}
                \EndIf 
            \EndIf

            \If{$NS$ = $None$ and $EW$ = $West\_Of$}
                \If{$S$ in $Q.NW$ \textbf{OR} $Q.SW$}
                    \State{\textbf{return}$True$}
                \EndIf 
            \EndIf
            \If{$NS$ = $None$ and $EW$ = $East\_of$}
                \If{$S$ in $Q.NE$ \textbf{OR} $Q.SE$}
                    \State{\textbf{return}$True$}
                \EndIf 
            \EndIf

        \EndProcedure
    \end{algorithmic}
\end{algorithm}


\paragraph{Query Input}
- algorithm for parsing from grid, etc.

\paragraph{Solution}
- recursive algorithm for finding any match
- complexity analysis

\paragraph{Experimental Results?}
- on ground truth queries? report number of locations pruned? timings?


%Concept mapping has been partially implemented in Python leveraging the \textit{Scipy} library\footnote{\href{https://pypi.org/project/scipy/}{SciPy PyPI Repo}}. Two different approaches have been trialed. 
%The first is simple dynamic arithmetic on the coordinates stored in a Pandas data frame. If one set of coordinates is above, below, left or right of another, it is north, south, east or west, respectively. 
%While these calculations are in constant time for straightforward comparisons of known objects (e.g. "is the pond west of the bridge"), the time complexity rapidly increases as soon as aggregations are employed. 
%Queries of "Give me everything west of the duck pond" would execute in $O(N)$ time as each element has to be examined. Worst-case queries would run in $O(N\sup{2})$ time, where every object is checked for its position relative to every other object. 

%The second (better) approach (only partially implemented) instantiates the objects within a location into a KD-Tree. 
%Assuming that the object centroid is the root, we can quickly complete queries like "Give me everything west of the duck pond" by leveraging the structure of the subtrees to return the requested set. 
%Similarly, getting the relative positions of two objects searches for a common ancestor. It uses the path between the children and their ancestor node to infer their spatial relation to each other.

%A third approach, designed to leverage the \textit{Neo4J Python Library}\footnote{\href{https://pypi.org/project/neo4j/}{Neo4J PyPI Repo}} to connect to a \textit{Neo4J Graph Database}\footnote{\href{https://neo4j.com/}{Neo4J Website}} but not implemented frames concept mapping as a graph traversal problem. 
%In this formulation, each object is a node on a graph. Weighted, labeled edges exist between each node within a given proximity threshold to the node. 
%The edge labels describe the neighboring node's cardinal direction and the distance weights. 
%After constructing the object graph, queries for 'give me everything west of the duck pond' would freely explore nodes connected by west, north and south edges. 
%It can only traverse along an east edge so long as the total cost of traveling east would be less than the cumulative value of the 'west' travel up to this point. 

%%Overall, concept mapping aims to enable geographic search over objects by explicitly representing their geospatial relationships to each other. 
%The author implemented a very basic approach using coordinate arithmetic was quickly determined to be infeasible for the extensive data sets that \textit{GESTALT} anticipates processing. 
%KD-Trees for the objects in each location have been implemented, as have the KD-Trees for the locations themselves. 
%This conceptual KD-Tree of KD-Trees approach performs a natural aggregation function which, provided that regions are created consistently, will allow for relative spatial queries at different levels of granularity. 
%Empirical evaluation of the performance of the arithmetic, KD-Tree and Graph-based approaches is yet to be completed. 



%%%%%%%%%%%%%%%NSCH clean up, incorporate, and delete the text below this point
Concept mapping is the process of determining the geospatial relations between objects. Much information is implicit in the relative positioning of objects within a location. For \textit{GESTALT}, there are three types of relations. 
The first is \textit{Static Cardinal Relations} which encodes whether an object is North, South, East or West of a location. Static Cardinal Relations support simple queries where the user knows that a location has a lake on its western side. 
The second is \textit{Dynamic Cardinal Relations} which determines whether an object is North, South, East or West of another object within a location. These queries support cases where a searcher might remember standing at a lake northeast of a location and that there was a swingset to the immediate west of them but still in the northeast of the location overall. 
The third are \textit{Positional Relations} which are applied to the two other types to enable reasoning about objects that are left, right, up, down, beside, behind etc., other objects. 
Positional relation use will be extensive because few humans think in cardinal directions, and most spatial reasoning is conducted from the person's perspective. 
Positional Relations enable users to query for locations where there is a letterbox on the left of the driveway as you enter the driveway while the house is in front of you. 

Concept mapping needs to be unsupervised and support aggregation. Tracking every object's relative location to every other object quickly becomes intractable, so mechanisms to aggregate depending on the level of granularity need to be applied. 
Accordingly, the underlying data structure must support aggregation and relative position querying. 