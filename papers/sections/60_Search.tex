\section{Search}
\label{section:search}

signpost here. \textbf{Define last-mile search, progressive search.....}

\subsection{Last-mile Search Conditions}
The core function of \textit{GESTALT} is searching. The search function assumes that the searcher only has partial information about a location. 
There are two elements of partial information. 
First is a general idea of the region in which the location occurs. Here region means the area surrounding a location. 
For example, in searching for a winery, it is assumed that the searcher knows that they are in the swan valley region of Western Australia. A region could be an administrative boundary like a city, suburb, or general geographic area. 
Either way, we assume that the searcher can prune their search space to the commencement of the \textit{last-mile} search before using \textit{GESTALT}.
The second assumes that the searcher knows a subset of the objects associated with a location. They may or may not know any of the attributes of those objects (for example, material, color etc). 


The search problem can then be framed in several ways, described in the subsequent subsections in increasing order of complexity and utility.

\subsection{Pruning the Search Space}
The first round of pruning occurs when the user selects the \emph{region} that they wish to search. 
\emph{GESTALT} is a last-mile search tool that assumes the user has a general idea of the location (region) that they wish to search. 
The second layer prunes out all locations that do not pass a set-membership test. The arrangement of objects in a location is irrelevant if they do not exist at a particular location, and so we avoid the computation of the spatial query in these cases. 
The third layer occurs during the search of the concept maps, with impossible results being pruned at each step to reduce the total search space to a tractable size.


\subsection{Exact Membership Search}
- problem definition

A \textit{set membership problem} is the most straightforward and most efficient. Given a set of locations, each of which has a set of objects it 'owns' and a set of objects in the search term, which locations have complete coverage of the search set.

- \nrscomment{algorithm SEARCH goes here}
- complexity

\subsection{Ranked Membership Search}
- problem definition
- \nrscomment{algorithm RANK goes here}
- complexity

\subsection{Fuzzy Membership Search}
- problem definition
- complexity

        
\begin{algorithm}
    \caption{Fuzzy Search}\label{alg:fuzzySearch}
    \begin{algorithmic}[2]
        \State{\textit{\textbf{QT} a list of query terms to search for}}
        \State{\textit{\textbf{II} an inverted index with objects as keys and locations as values}}
        \State{- - - - -}
        \Procedure{fuzzySearch}{$QT$,$II$}
            \State{$S$= \textbf{II.SEARCH}($QT$)}
            \If{$S$ is Empty}
                \State{$q$ = Pop most discriminative term from $QT$}
                \State{$S$= \textbf{$II$.SEARCH}($QT$)}
                \If{$S$ is not Empty}
                    \State{Skip to Line 6}
                \Else
                    \State{$S$= \textbf{II.SEARCH}($QT$.remove($q$)}
                \EndIf
            \EndIf
            \If{$S$ has more than 1 item}
                \State{\textbf{return} \textbf{$II$.RANK($S$,$Q$)}}
            \EndIf
        \EndProcedure
    \end{algorithmic}
\end{algorithm}


\begin{algorithm}
    \caption{Search}\label{alg:search}
    \begin{algorithmic}
        \State{\textit{\textbf{QT} a list of query terms to search for}}
        \State{\textit{\textbf{II} an inverted index with objects as keys and locations as values}}
        \State{- - - - -}
        \Procedure{Search}{$QT$,$II$}
            \State{$Locs$ = []}
            \For{Each $q$ in $QT$}
                \State{Retrieve set of Locations $II$[$q$] and add to $Locs$}
            \EndFor
            \State{\textbf{return} intersection of sets of Locations in $Locs$}
            \EndProcedure
    \end{algorithmic}
\end{algorithm}


\begin{algorithm}
    \caption{Rank}\label{alg:rank}
    \begin{algorithmic}
        \State{\textit{\textbf{QT} a list of query terms to search for}}
        \State{\textit{\textbf{II} an inverted index with objects as keys and locations as values}}
        \State{- - - - -}
        \Procedure{Rank}{$S$,$q$,$II$}\Comment{$S$ results from $q$ query terms in $II$}
            \State{$LR$ = Empty Ordered Dictionary}\Comment{\textbf{L}ocation \textbf{R}ank}
            \For{Each $L$ in $S$}\Comment{\textbf{L}ocation}
                \State{$p$ = 1}\Comment{Probability location correct}
                \For{$O$ in $q$}
                    \State{$OP$ = Prob of Obj@Locin $II$}\Comment{\textbf{O}bject \textbf{P}robability}
                    \State{$P$ = $P$x$OP$}
                \EndFor
                \State{$LR$[$L$] = $P$}
            \EndFor
            \State{\textbf{return}$LR$ ordered most to least likely}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}


\subsection{Spatial Search}
% NSCH need to rewrite the below chunk
Spatial search incorporates the concept of mapping and becomes a spatial search with a specific method depending on the objects' underlying data structure. 
The general case is as follows: Given a set of locations with geospatial mappings of their child objects and a subset of those geospatial mappings of child objects which location does that subset match? 
If using a graph structure, each location's objects become a graph where the objects are nodes and the geospatial relations are edges encoding the spatial relations (e.g. west of, north of). It is a subgraph matching problem, which is, of course, NP-Complete. 
Alternately, representing each location's objects as a KD-Tree rooted on the centroid of the object cluster would allow for dynamic searching. For example, assuming an initial split on the longitude of objects, we could immediately tell that all objects in the left subtree would be west of that root. 
For either of these geospatial approaches, a translation layer from the positional relational to cardinal relational will need to occur.

\subsubsection{UI for Query Specification}
- description
- picture of the UI
- refer to appendix algorithm(s) for mapping input to usable form?
Intuitively we want to be able to compare a user's sketch map to the real world locations \emph{GESTALT} records. 

\subsubsection{Method}
For object-location, the method is easy because we just check \nrscomment{....describe in a sentence or two...}

For object-object search, \nrscomment{....describe the method, refer to algo below....}

\begin{algorithm}
    \caption{Recursive Grid Search}\label{alg:gridSearch}
    \begin{algorithmic}
        \State{\textit{\textbf{M} A ConceptMap Matrix with objects or 0s; [0,0] is NW most point}}
        \State{\textit{\textbf{L} A NW to SE ordered list of objects to search for}}
        \State{\textit{\textbf{D} The direction of Pruning, 'northToSouth' or 'westToEast'}}
        \State{- - - - -}
        \Procedure{recursiveGridSearch}{$M$,$L$,$D$} %\Comment{$M$ a matrix of a Loc's objects, $L$ an ordered list of objects to search for, $D$ is the pruning direction}
            \If{$L$ has only 1 item}\Comment{Base Case}
                \If{pop($L$) in $M$}
                    \State{\textbf{return} $True$}              
                \Else
                    \State{\textbf{return} $False$}
                \EndIf            
            \EndIf
            \If{$D$ is $northToSouth$}
                \State{$NorthernObject$ = pop($L$)}                
                \If{$NorthernObject$ not in $M$}
                    \State{\textbf{return} $False$}               
                \EndIf
                \State{$M$ = Prune all objects north of $NorthernObject$}
                \State{\textbf{return recursiveGridSearch}($M$,$L$,$westToEast$)}
            \EndIf
            \If{$D$ is $eastToWest$}
                \State{$WesternObject$ = pop($L$)}
                \If{$WesternObject$ not in $M$}
                    \State{\textbf{return} $False$}
                \EndIf
                \State{$M$ = Prune all objects west of $WesternObject$}
                \State{\textbf{return recursiveGridSearch}($M$,$L$,$northToSouth$)}
            \EndIf
        \EndProcedure
    \end{algorithmic}
\end{algorithm}


\subsubsection{Results on Ground Truth Spatial Queries}
End to end including object-object and object-location concept mapping

- table listing the 12 location-object queries and expected results

- visually show the object object ground truth queries in a grid of subplots?

%The search function has been implemented using the Python \textit{Pandas}\footnote{https://pypi.org/project/pandas/}{Pandas PyPI Repo} library. 
%This approach assumes a single data frame of objects and their determined locations because of the number of possible attributes an object can have and the relatively few that they possess, this is a sparse data structure. 
%The sparseness does indicate the discriminatory power of remembering attributes. For example, a 'door' is not informative, but a 'blue door' on your favorite seaside restaurant is more likely to prune the search space. 
%Because \textit{GESTALT} is designed only for the last-mile search and assumes a small starting region, it may remain feasible to use a simple data structure like a Pandas data frame containing all the objects for all the locations for the query region. 
%More work with the aggregation functions is required to determine if it can support all the necessary aggregation queries comparing object collections. 

%Semantic search has not been implemented. However, the Levenshtein string distance metric (with $threshold = 0.8$) checks for small spelling discrepancies in input words. The priority weights towards retrieving all possible objects, so we accept the increased risk of mistakenly including an object to move the recall closer to 100\%. The next component to be implemented is a nearest-neighbor retrieval mechanism using word embeddings. Prior work indicates that developing databases of embeddings is trivial\cite{Mueller2012}, but using existing datasets tools like word2vec, GloVe and fasttext can generate embeddings over large, publicly available corpora that can be recreated. 

%As discussed in the subsection on Ownership Assignment implementation, bloom filters are a much more efficient operator for set membership testing. 
%The KD-Tree is more suited for geospatial queries, so the Pandas Dataframe currently supports the gaps between the two in supporting aggregation queries. More work is required to integrate these data structures into a coherent search pipeline that maximizes recall while actively pruning the search space at every step so that the searcher can find their locations of interest. Natural language querying is an active area of research yet to present a solution capable of effectively translating natural language queries and their SQL solutions. Given the relatively constrained domain of this problem set, it is a good candidate for implementation as a low priority for improvement. 


\subsection{Scalability}
%Automating the labeling process is essential to scaling \textit{GESTALT} beyond a trivial size. 
%Options for automation are explored in detail in sections \ref{section:architecture} and \ref{section:related}, but essentially rely on combining remote sensing imagery, ground-based imagery and image metadata to generate mappings of objects to coordinates and parent locations.
%The ability to autonomously determine object locations will set the conditions for the remaining elements of GESTALT to scale.

This multiple-ownership situation is one of the driving requirements for implementing concept mapping to extract additional discriminatory information between locations based on the geospatial layout of objects.

Spatial queries are the most computationally intensive aspect of the search.
Object-Centric queries require a concept map that describes all n-ary object-object relations, where Location-Centric queries only need describe the set of binary object-location relations.
These problems of searching by geographic sets of objects have previously been characterized as graph-matching problems. 
As a graph-matching problem, the difference between a fully connected graph, and a hub-and-spoke graph is significant, particularly as the number of vertices increases. It quickly becomes intractable. \osullikomment{[CITE HERE]}
We handle both these types of queries by focusing on pruning the search space down to a reasonable size before checking the spatial relationships between objects.

- for spatial results report number of locations pruned? timings?


The worst case complexity is for a search of N object terms where every object category is mapped to every location L. In that case we have to do N lookups to pull N sets of size L and intersect them. Realistically this would not happen and some object classes would be very discriminative and we could intersect those first to be more efficient.




%The search problem must balance precision and recall while not being computationally intractable. An effective search process will use bloom filters to prune the search space for the more complicated geospatial search. Semantic enrichment should be applied independently at each stage of the search in an attempt to improve the recall of \textit{GESTALT}.