\section{Search}
\label{section:search}

The core function of \textit{GESTALT} is to perform last-mile search given partial or uncertain information.
The user is assumed to know the general region of interest and some information about the objects at the location they seek.
Under these conditions, the search problem can be framed in several ways, which we describe below in increasing order of complexity and utility.

\subsection{Membership Search}

\subsubsection{Exact membership search}
A \textit{set membership problem} is the most straightforward and most efficient. Given a set of locations, each of which has a set of objects it 'owns' and a set of objects in the search term, which locations have complete coverage of the search set.



\begin{algorithm}
    \caption{Search}\label{alg:search}
    \begin{algorithmic}
        \State{\textit{\textbf{QT} a list of query terms to search for}}
        \State{\textit{\textbf{II} an inverted index with objects as keys and locations as values}}
        \State{- - - - -}
        \Procedure{Search}{$QT$,$II$}
            \State{$Locs$ = []}
            \For{Each $q$ in $QT$}
                \State{Retrieve set of Locations $II$[$q$] and add to $Locs$}
            \EndFor
            \State{\textbf{return} intersection of sets of Locations in $Locs$}
            \EndProcedure
    \end{algorithmic}
\end{algorithm}


\subsubsection{Ranked membership search}


\begin{algorithm}
    \caption{Rank}\label{alg:rank}
    \begin{algorithmic}
        \State{\textit{\textbf{QT} a list of query terms to search for}}
        \State{\textit{\textbf{II} an inverted index with objects as keys and locations as values}}
        \State{- - - - -}
        \Procedure{Rank}{$S$,$q$,$II$}\Comment{$S$ results from $q$ query terms in $II$}
            \State{$LR$ = Empty Ordered Dictionary}\Comment{\textbf{L}ocation \textbf{R}ank}
            \For{Each $L$ in $S$}\Comment{\textbf{L}ocation}
                \State{$p$ = 1}\Comment{Probability location correct}
                \For{$O$ in $q$}
                    \State{$OP$ = Prob of Obj@Locin $II$}\Comment{\textbf{O}bject \textbf{P}robability}
                    \State{$P$ = $P$x$OP$}
                \EndFor
                \State{$LR$[$L$] = $P$}
            \EndFor
            \State{\textbf{return}$LR$ ordered most to least likely}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}


\subsection{Fuzzy Membership Search}
\nrscomment{
- problem definition
- complexity}

\nrscomment{TIMINGS show num locations vs time}

        
\begin{algorithm}
    \caption{Fuzzy Search}\label{alg:fuzzySearch}
    \begin{algorithmic}[2]
        \State{\textit{\textbf{QT} a list of query terms to search for}}
        \State{\textit{\textbf{II} an inverted index with objects as keys and locations as values}}
        \State{- - - - -}
        \Procedure{fuzzySearch}{$QT$,$II$}
            \State{$S$= \textbf{II.SEARCH}($QT$)}
            \If{$S$ is Empty}
                \State{$q$ = Pop most discriminative term from $QT$}
                \State{$S$= \textbf{$II$.SEARCH}($QT$)}
                \If{$S$ is not Empty}
                    \State{Skip to Line 6}
                \Else
                    \State{$S$= \textbf{II.SEARCH}($QT$.remove($q$)}
                \EndIf
            \EndIf
            \If{$S$ has more than 1 item}
                \State{\textbf{return} \textbf{$II$.RANK($S$,$Q$)}}
            \EndIf
        \EndProcedure
    \end{algorithmic}
\end{algorithm}


\subsection{Spatial Search}

The most powerful form of search \emph{GESTALT} enables is spatial search, where users can query for locations based on the spatial configuration of objects in relation to each other or to the location itself.
However, as discussed in section \ref{section:concept}, this problem quickly becomes intractable as the number of objects increases.
To combat this effect and still enable users to specify spatial queries, we employ a successive pruning approach, where the search space is scoped down in stages until the resulting search is of reasonable scale to perform quickly.

\subsubsection{Pruning the Search Space}
The first round of pruning occurs when the user selects the \emph{region} that they wish to search (a pre-condition to performing last-mile search). 
The second layer of pruning happens when the exact membership search method is applied to the query objects.
The set-membership test prunes out any locations that do not contain the objects of interest, thereby avoiding unnecessary computation associated with determining the spatial configuration of objects that are irrelevant to the query (i.e. that belong to locations that are not candidates).
The third layer of pruning occurs during the search of the concept maps. 
The recursive grid search (Algorithm \ref{alg:geoToGrid}) successively segments the search grid into smaller and smaller sections, eliminating impossible results at each step to reduce the total search space to a tractable size.

\subsubsection{Specifying the Query Pictorially}
A picture is worth a thousand words, and maps are an ingerently visual medium. \emph{GESTALT} recognises the expressive limitations of words alone for geospatial querying and invites a user to query its database with quick sketch maps. 
The pictorial query specification abstracts away the need for the user to describe the relations of objects using the confusing language around cardinal directions, and replaces it with the simple visual task of trying to recreate the pattern being held in your mind's eye.
We implement a very rudimentary prototype pictorial query interface using Python Tkinter.
The interface has two modes. 
Figure \ref{fig:GUI-LO} shows the location-object configuration, where the coordinates of the location are placed at the centre of the canvas and all objects positioned around that centrepoint by the user. 
The second mode shown in Figure \ref{fig:GUI-OO} is the object-object configuration, where the canvas space allows users to place patterns of objects that they recall in space without concern for their loations respective to the location itself. If that pattern of objects exists in the database, \emph{GESTALT} returns the result. Detail on how the underlying data structures are consturcted are available in the Appendices in Appendix \ref{alg:geoToGrid}.

\subsubsection{Searching the Concept Maps}
Searching the object-location concept maps requires the user to specify a query, either pictorially or with keywords, for each quadrant of an unknown candidate location, what objects they expect to find there.
Using that query input, the searher iterates through each location and inspects its NW/NE/SW/SE subdivisions of space, comparing them to the query. 
Where the same object occurs in the same quadrant in the query and a candidate location, one point is added to the location's score. 
When all locations have been checked, the candidate locations (i.e. locations with $> 1$ match) are returned, ranked from most to fewest matches. 

Searching the object-object concept maps requires the user to specify a query pictorially. 
That query is converted into a concept map matrix, and the search terms within that matrix are ordered into a queue with the most northern point at index 0, the most western at index 1 and continuing until the most southEasterly query term is at the tail of the queue. 
Given the query list, algorithm \ref{alg:gridSearch} details the process of recursively pruning the search space. 
The broad idea is that while finding all possible instances and configurations of a geospatial pattern rapidly approaches NP-Completeness, we can determine if there is any possible match quite easily by using the query term to prune sections of the concept map that are irrelevant. 
For example, any objects in the location that are north of the most northerly query term that exists in the object cannot possibly satisfy the query, and so we prune those rows. 
The same occurs for the western direction, and then recursively north and west until the query is eithers satisfied or rejected. The search occurs for each candidate location and requires less than a single matrix traversal to determine if anywhere in that location the query pattern occurs. 

\begin{algorithm}
    \caption{Recursive Grid Search}\label{alg:gridSearch}
    \begin{algorithmic}
        \State{\textit{\textbf{M} A ConceptMap Matrix with objects or 0s; [0,0] is NW most point}}
        \State{\textit{\textbf{L} A NW to SE ordered list of objects to search for}}
        \State{\textit{\textbf{D} The direction of Pruning, 'northToSouth' or 'westToEast'}}
        \State{- - - - -}
        \Procedure{recursiveGridSearch}{$M$,$L$,$D$} %\Comment{$M$ a matrix of a Loc's objects, $L$ an ordered list of objects to search for, $D$ is the pruning direction}
            \If{$L$ has only 1 item}\Comment{Base Case}
                \If{pop($L$) in $M$}
                    \State{\textbf{return} $True$}              
                \Else
                    \State{\textbf{return} $False$}
                \EndIf            
            \EndIf
            \If{$D$ is $northToSouth$}
                \State{$NorthernObject$ = pop($L$)}                
                \If{$NorthernObject$ not in $M$}
                    \State{\textbf{return} $False$}               
                \EndIf
                \State{$M$ = Prune all objects north of $NorthernObject$}
                \State{\textbf{return recursiveGridSearch}($M$,$L$,$westToEast$)}
            \EndIf
            \If{$D$ is $eastToWest$}
                \State{$WesternObject$ = pop($L$)}
                \If{$WesternObject$ not in $M$}
                    \State{\textbf{return} $False$}
                \EndIf
                \State{$M$ = Prune all objects west of $WesternObject$}
                \State{\textbf{return recursiveGridSearch}($M$,$L$,$northToSouth$)}
            \EndIf
        \EndProcedure
    \end{algorithmic}
\end{algorithm}


\subsubsection{Results on Ground Truth Spatial Queries}
\nrscomment{tabulate prec/recall based on Kent's results posted in slack}
End to end including object-object and object-location concept mapping

- table listing the 12 location-object queries and expected results

- calc prec/recall for obj-obj and obj-loc

- visually show the object object ground truth queries in a grid of subplots?




\subsection{Scalability}

\nrscomment{Kent run:
query 10 bus stops with obj-obj pictorial, report query time and num locations pruned by concept map
query 10 bus stops with obj-loc pictorial, report query time and num locations pruned by concept map
query 10 bus stops and 10 trees with obj-obj, report query time and num locations pruned by concept map
query 10 bus stops and 10 trees with obj-loc, report query time and num locations pruned by concept map
query 10 bus stops and 10 trees and 10 benches with obj-obj, report query time and num locations pruned by concept map
query 10 bus stops and 10 trees and 10 benches with obj-loc, report query time and num locations pruned by concept map
}

This multiple-ownership situation is one of the driving requirements for implementing concept mapping to extract additional discriminatory information between locations based on the geospatial layout of objects.

Spatial queries are the most computationally intensive aspect of the search.
Object-Centric queries require a concept map that describes all n-ary object-object relations, where Location-Centric queries only need describe the set of binary object-location relations.
These problems of searching by geographic sets of objects have previously been characterized as graph-matching problems. 
As a graph-matching problem, the difference between a fully connected graph, and a hub-and-spoke graph is significant, particularly as the number of vertices increases. It quickly becomes intractable. \osullikomment{[CITE HERE]}
We handle both these types of queries by focusing on pruning the search space down to a reasonable size before checking the spatial relationships between objects.

- for spatial results report number of locations pruned? timings?


The worst case complexity is for a search of N object terms where every object category is mapped to every location L. In that case we have to do N lookups to pull N sets of size L and intersect them. Realistically this would not happen and some object classes would be very discriminative and we could intersect those first to be more efficient.




%The search problem must balance precision and recall while not being computationally intractable. An effective search process will use bloom filters to prune the search space for the more complicated geospatial search. Semantic enrichment should be applied independently at each stage of the search in an attempt to improve the recall of \textit{GESTALT}.

%\subsection{Last-mile Search Problem}
%First is a general idea of the region in which the location occurs. 
%Here region means the area surrounding a location. 
%For example, in searching for a winery, it is assumed that the searcher knows that they are in the swan valley region of Western Australia. 
%A region could be an administrative boundary like a city, suburb, or general geographic area. 
%Either way, we assume that the searcher can prune their search space to the commencement of the \textit{last-mile} search before using \textit{GESTALT}.
%The second assumes that the searcher knows a subset of the objects associated with a location. 
%They may or may not know any of the attributes of those objects (for example, material, color etc).

%\emph{GESTALT} is a last-mile search tool that assumes the user has a general idea of the location (region) that they wish to search. 

%Spatial search incorporates the concept of mapping and becomes a spatial search with a specific method depending on the objects' underlying data structure. 
%The general case is as follows: Given a set of locations with geospatial mappings of their child objects and a subset of those geospatial mappings of child objects which location does that subset match? 
%If using a graph structure, each location's objects become a graph where the objects are nodes and the geospatial relations are edges encoding the spatial relations (e.g. west of, north of). It is a subgraph matching problem, which is, of course, NP-Complete. 
%Alternately, representing each location's objects as a KD-Tree rooted on the centroid of the object cluster would allow for dynamic searching. For example, assuming an initial split on the longitude of objects, we could immediately tell that all objects in the left subtree would be west of that root. 
%For either of these geospatial approaches, a translation layer from the positional relational to cardinal relational will need to occur.

%Automating the labeling process is essential to scaling \textit{GESTALT} beyond a trivial size. 
%Options for automation are explored in detail in sections \ref{section:architecture} and \ref{section:related}, but essentially rely on combining remote sensing imagery, ground-based imagery and image metadata to generate mappings of objects to coordinates and parent locations.
%The ability to autonomously determine object locations will set the conditions for the remaining elements of GESTALT to scale.

%The search function has been implemented using the Python \textit{Pandas}\footnote{https://pypi.org/project/pandas/}{Pandas PyPI Repo} library. 
%This approach assumes a single data frame of objects and their determined locations because of the number of possible attributes an object can have and the relatively few that they possess, this is a sparse data structure. 
%The sparseness does indicate the discriminatory power of remembering attributes. For example, a 'door' is not informative, but a 'blue door' on your favorite seaside restaurant is more likely to prune the search space. 
%Because \textit{GESTALT} is designed only for the last-mile search and assumes a small starting region, it may remain feasible to use a simple data structure like a Pandas data frame containing all the objects for all the locations for the query region. 
%More work with the aggregation functions is required to determine if it can support all the necessary aggregation queries comparing object collections. 

%Semantic search has not been implemented. However, the Levenshtein string distance metric (with $threshold = 0.8$) checks for small spelling discrepancies in input words. The priority weights towards retrieving all possible objects, so we accept the increased risk of mistakenly including an object to move the recall closer to 100\%. The next component to be implemented is a nearest-neighbor retrieval mechanism using word embeddings. Prior work indicates that developing databases of embeddings is trivial\cite{Mueller2012}, but using existing datasets tools like word2vec, GloVe and fasttext can generate embeddings over large, publicly available corpora that can be recreated. 

%As discussed in the subsection on Ownership Assignment implementation, bloom filters are a much more efficient operator for set membership testing. 
%The KD-Tree is more suited for geospatial queries, so the Pandas Dataframe currently supports the gaps between the two in supporting aggregation queries. More work is required to integrate these data structures into a coherent search pipeline that maximizes recall while actively pruning the search space at every step so that the searcher can find their locations of interest. Natural language querying is an active area of research yet to present a solution capable of effectively translating natural language queries and their SQL solutions. Given the relatively constrained domain of this problem set, it is a good candidate for implementation as a low priority for improvement. 