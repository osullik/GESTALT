\section{Search}
\label{section:search}

The core function of \textit{GESTALT} is to perform last-mile search given partial or uncertain information.
The user is assumed to know the general region of interest and some information about the objects at the location they seek.
Under these conditions, the search problem can be framed in several ways, which we describe below in increasing order of complexity and utility.

\begin{algorithm}
    \caption{Search}\label{alg:search}
    \begin{algorithmic}
        \State{\textit{\textbf{QT} a list of query terms to search for}}
        \State{\textit{\textbf{II} an inverted index with objects as keys and locations as values}}
        \State{- - - - -}
        \Procedure{Search}{$QT$,$II$}
            \State{$Locs$ = []}
            \For{Each $q$ in $QT$}
                \State{Retrieve set of Locations $II$[$q$] and add to $Locs$}
            \EndFor
            \State{\textbf{return} intersection of sets of Locations in $Locs$}
            \EndProcedure
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Fuzzy Search}\label{alg:fuzzySearch}
    \begin{algorithmic}[2]
        \State{\textit{\textbf{QT} a list of query terms to search for}}
        \State{\textit{\textbf{II} an inverted index with objects as keys and locations as values}}
        \State{- - - - -}
        \Procedure{fuzzySearch}{$QT$,$II$}
            \State{$S$= \textbf{II.SEARCH}($QT$)}
            \If{$S$ is Empty}
                \State{$q$ = Pop most discriminative term from $QT$}
                \State{$S$= \textbf{$II$.SEARCH}($QT$)}
                \If{$S$ is not Empty}
                    \State{Skip to Line 6}
                \Else
                    \State{$S$= \textbf{II.SEARCH}($QT$.remove($q$)}
                \EndIf
            \EndIf
            \If{$S$ has more than 1 item}
                \State{\textbf{return} \textbf{$II$.RANK($S$,$Q$)}}
            \EndIf
        \EndProcedure
    \end{algorithmic}
\end{algorithm}


\subsection{Membership Search}

\subsubsection{\textbf{Exact membership search}}
The simplest search function in \emph{GESTALT} (Algorithm \ref{alg:search}) takes a set of query terms representing objects the user knows are at a location, and performs the appropriate look-ups and set intersections to determine which locations are a match for containing \textit{all} those objects.

%A \textit{set membership problem} is the most straightforward and most efficient. Given a set of locations, each of which has a set of objects it 'owns' and a set of objects in the search term, which locations have complete coverage of the search set.
\subsubsection{\textbf{Ranked membership search}}
When the exact membership search returns a large number of hits, such as for a broad query (i.e. Which locations have a tree and a bench?) the ranking of those locations can help narrow the results. Using Algorithm \ref{alg:rank}, we aggregate the confidence scores from the object tagging and ownership assignment stages to determine the overall likelihood that a given location contains the object of interest. These scores are then aggregated per location for the relevant query objects, and the final scores determine the ranking of the results. 

\subsubsection{\textbf{Fuzzy Membership Search}}
When the exact membership search returns no matching locations, we use a fuzzy search procedure (Algorithm \ref{alg:fuzzySearch}) to find a set of partial match locations based on the most discriminative object(s) in the list of query terms provided. 
The most discriminative terms are emphasized since rare objects are memorable and more uniquely identify locations than common objects do.
%Fuzzy search begins with the most discriminative query term (based on counts maintained by the inverted index) and proceeds by adding query terms successively until the set intersection returns no locations matching all the criteria, at which point it walks back by one term and returns the prvious set of locations, which is the closest match.

%\subsubsection{Scalability}


%on several queries over the Washington D.C. dataset to demonstrate the scalability of the membership search functionality of \emph{GESTALT}. 

%\nrscomment{Kent, plot num locations vs time for fuzzy search runs}

        


\subsection{Spatial Search}

The most powerful form of search \emph{GESTALT} enables is spatial search, where users can query for locations based on the spatial configuration of objects in relation to each other or to the location itself.
However, as discussed in section \ref{section:concept}, this problem quickly becomes intractable as the number of objects increases.
To combat this effect and still enable users to specify spatial queries, we employ a successive pruning approach, where the search space is scoped down in stages until the resulting search is of reasonable scale to execute directly.

\subsubsection{Pruning the Search Space}
The first round of pruning occurs when the user selects the \emph{region} that they wish to search (a pre-condition to performing last-mile search). 
The second layer of pruning happens when the exact membership search method is applied to the query objects.
The set-membership test prunes out any locations that do not contain the objects of interest, thereby avoiding unnecessary computation associated with determining the spatial configuration of objects that are irrelevant to the query (i.e. that belong to locations that are not candidates).
The third layer of pruning occurs during the search of the concept maps. 
The recursive grid search (Algorithm \ref{alg:geoToGrid}) successively segments the search grid into smaller and smaller sections, eliminating impossible results at each step to reduce the total search space to a tractable size.

\subsubsection{Specifying the Query Pictorially}
%A picture is worth a thousand words, and maps are an inherently visual medium. \emph{GESTALT} recognizes the expressive limitations of words alone for geospatial querying and invites a user to query its database with quick sketch maps. 
Humans naturally conceive of and express geospatial relationships visually.
In keeping with a human-centric approach to spatial search, \emph{GESTALT} employs a pictorial query interface that encodes the relative positioning of objects and locations to enable search over those relations.
Figure \ref{fig:GUI-LO} shows the location-object query interface, where the location being sought is represented at the center of the canvas and a user issues a query by positioning objects around that center point. 
Figure \ref{fig:GUI-OO} demonstrates the object-object query interface, where users define the spatial arrangement of objects they want to query by placing the object names on the canvas space. 
%specification abstracts away the need for the user to describe the relations of objects using the confusing language around cardinal directions, and replaces it with the simple visual task of trying to recreate the pattern being held in your mind's eye.
%We implement a very rudimentary prototype pictorial query interface using Python Tkinter.
%The interface has two modes. 

\subsubsection{Searching the Concept Maps}
To avoid unnecessary computation, the spatial searches are only performed after the initial membership check has been done to narrow the pool of locations to those that contain the right set of objects.
Searching the object-location concept maps involves a simple iteration through the candidate locations, searching each one's NW/NE/SW/SE quadrants for the relevant query objects, and ranking the locations based on how many objects were found in the correct quadrant. 
%requires the user to specify a query, either pictorially or with keywords, for each quadrant of an unknown candidate location, what objects they expect to find there.
%Using that query input, the searcher iterates through each location and inspects its NW/NE/SW/SE subdivisions of space, comparing them to the query. 
%Where the same object occurs in the same quadrant in the query and a candidate location, one point is added to the location's score. 
%When all locations have been checked, the candidate locations (i.e. locations with $> 1$ match) are returned, ranked from most to fewest matches. 
Searching the object-object concept maps involves using the recursive grid search (Algorithm \ref{alg:gridSearch}) to identify which locations have objects matching the configuration specified in the pictorial query, and returning the relevant set of results. 
The pictorial query is first converted into a concept map matrix using the process outlined in Appendix \ref{appendix:conceptcreation} and the search terms in the matrix are ordered into a queue with the northernmost enqueued first, followed by the westernmost, then the second northernmost, and so on until all search terms are in the queue.
Then, the grid search is employed to recursively prune the search space and quickly eliminate candidate locations that do not match the query configuration.
This process is depicted visually in Figure \ref{figure:ConceptMap}.
%NSCH add back in if room allows:
%The broad idea is that while finding all possible instances and configurations of a geospatial pattern rapidly approaches NP-Completeness, we can determine if there is any possible match quite easily by using the query term to prune sections of the concept map that are irrelevant. 
%For example, any objects in the location that are north of the most northerly query term that exists in the object cannot possibly satisfy the query, and so we prune those rows. 
%The same occurs for the western direction, and then recursively north and west until the query is eithers satisfied or rejected. The search occurs for each candidate location and requires less than a single matrix traversal to determine if anywhere in that location the query pattern occurs. 

\begin{algorithm}
    \caption{Recursive Grid Search}\label{alg:gridSearch}
    \begin{algorithmic}
        \State{\textit{\textbf{M} A ConceptMap Matrix with objects or 0s; [0,0] is NW most point}}
        \State{\textit{\textbf{L} A NW to SE ordered list of objects to search for}}
        \State{\textit{\textbf{D} The alternating direction we prune from, 'north' (default) or 'west'}}
        \State{- - - - -}
        \Procedure{recursiveGridSearch}{$M$,$L$,$D$} %\Comment{$M$ a matrix of a Loc's objects, $L$ an ordered list of objects to search for, $D$ is the pruning direction}
            \If{$L$ has only 1 item}\Comment{Base Case}
                \If{pop($L$) in $M$}
                    \State{\textbf{return} $True$}              
                \Else
                    \State{\textbf{return} $False$}
                \EndIf            
            \EndIf
            \State{$PruningPoint\leftarrow$ pop($L$)}                
            \If{$PruningPoint$ not in $M$}
                \State{\textbf{return} $False$}               
            \EndIf
            \State{$M^\prime \leftarrow$ Prune all objects $D$ of $PruningPoint$}
            \State{\textbf{return recursiveGridSearch}($M^\prime$,$L$,$D.\textbf{changeDirection}()$)}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

%\begin{algorithm}
%    \caption{Recursive Grid Search}\label{alg:gridSearch}
%    \begin{algorithmic}
%        \State{\textit{\textbf{M} A ConceptMap Matrix with objects or 0s; [0,0] is NW most point}}
%        \State{\textit{\textbf{L} A NW to SE ordered list of objects to search for}}
%        \State{\textit{\textbf{D} The direction of Pruning, 'northToSouth' or 'westToEast'}}
%        \State{- - - - -}
%        \Procedure{recursiveGridSearch}{$M$,$L$,$D$} %\Comment{$M$ a matrix of a Loc's objects, $L$ an ordered list of objects to search for, $D$ is the pruning direction}
%            \If{$L$ has only 1 item}\Comment{Base Case}
%                \If{pop($L$) in $M$}
%                    \State{\textbf{return} $True$}              
%                \Else
%                    \State{\textbf{return} $False$}
%                \EndIf            
%            \EndIf
%            \If{$D$ is $northToSouth$}
%                \State{$NorthernObject\leftarrow$ pop($L$)}                
%                \If{$NorthernObject$ not in $M$}
%                    \State{\textbf{return} $False$}               
%                \EndIf
%               \State{$M\leftarrow$ Prune all objects north of $NorthernObject$}
%                \State{\textbf{return recursiveGridSearch}($M$,$L$,$westToEast$)}
%            \EndIf
%            \If{$D$ is $eastToWest$}
%                \State{$WesternObject\leftarrow$ pop($L$)}
%                \If{$WesternObject$ not in $M$}
%                    \State{\textbf{return} $False$}
%                \EndIf
%                \State{$M\leftarrow$ Prune all objects west of $WesternObject$}
%                \State{\textbf{return recursiveGridSearch}($M$,$L$,$northToSouth$)}
%            \EndIf
%       \EndProcedure
%    \end{algorithmic}
%\end{algorithm}


\subsubsection{Results on Ground Truth Spatial Queries}

\small{
\begin{table}[h!]
    \begin{center}
        \begin{tabular}{ |c|c|c|c| } 
            \hline
            Query Method & Metric & Results \\
            \hline
            \multirow{2}{7em}{Loc-Obj} & Mean Precision & $0.854$ \\
            & Mean Recall & $0.917$\\%& 
            \hline     
            \multirow{2}{7em}{Obj-Obj} & Mean Precision & $0.721$ \\ 
            &Mean Recall & $0.875$ \\
            \hline
        \end{tabular}
        \caption{Spatial results across 24 ground-truth pictorial queries run on the \textit{combined swan valley wineries} dataset.} %Clustering used DBSCAN with $\epsilon = \frac{0.05}{6371}$ and MinCluster=$3$.} 
        \label{Table:GroundTruth}
    \end{center}
\end{table}
}
We hand labeled the ground truth responses for 24 spatial queries on object configurations for objects belonging to the 6 wineries in the Swan Valley Wineries dataset. 
To test the overall recall of \emph{GESTALT}'s spatial search process in a noisy environment, we test those queries on the \textit{Combined} dataset.
The results (Table \ref{Table:GroundTruth}) show that \emph{GESTALT} has a high recall on both methods of query specification, object-location and object-object.
We expect precision to be low on these query results when compared to the ground-truth, since the \textit{Combined} dataset includes many additional locations that were not considered during the hand-labeling.
However, the precision we recorded is reasonable, which points to the discriminative power of spatial configurations of objects as a search constraint.

%ran 12 queries on each pictorial querying method and record the results in table \ref{Table:GroundTruth}. 
%The recall of the Loc-Obj queries tends to increase with the number of query terms, as they are additive. 
%The precision of the obj-obj queries is negatively impacted by single term queries, which returns any location with that object present.

\subsection{Scalability}

\small{
\begin{figure}[h]
    \centering
    \begin{subfigure}[t]{.45\textwidth}
        \includesvg[width=\textwidth]{queryExecutionRecall.svg}
        
        %\caption{Additional terms improve precision of results for all techniques except Loc-Obj Pictorial Querying, for which each search term adds to possible matches, rather than pruning impossible matches. Users seeking to prune their search space should seek to input 3 objects to \emph{GESTALT}}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{.45\textwidth} 
        \includesvg[width=\textwidth]{queryExecutionTime.svg}
        %\caption{Query time remains constant for Pictorial Obj-Obj querying after a second item because it only requires a single matrix traversal per location to match the query pattern to that candidate location. The set intersections in our Index Searches are order-optimized to execute the most discriminitive sets first in queries.}    
    \end{subfigure}

    \caption{Number of candidate locations and query response times for queries on the Washington D.C. Dataset (12,179 Locations, 91,188 objects).}\label{figure:PerformanceExperiments}\label{fig:queryExecutionRecall}        \label{fig:queryExecutionTime}
    %A suite of queries run across the DC Dataset (12179 Locations, 148 Distinct classes among 91188 objects) clustered using DBSCAN with $\epsilon=0.00000156961$ (roughly 50m),MinCluster=$3$ and out Fuzzy Threshold$=0.0$. We use the 10 most common object classes: (eg crossing, traffic signals, street lamp, bus stop) to simulate worst case conditions where the user recalls almost no distinguishing features of their target location} 
\end{figure}
}

Figure \ref{fig:queryExecutionTime} shows the query response times on the Washington D.C. dataset (with over 91,000 objects and 12,000 locations) as the number of query terms increases. 
The queries tested were constructed using the 10 most common object classes: (e.g. crossing, traffic signals, street lamp, bus stop) to simulate worst case conditions where the user recalls no highly distinctive features of their target location.
For the three membership searches (exact, ranked, and fuzzy), the response times decrease as the number of objects specified in the query increases (i.e. as the pool of possible locations meeting the query specification narrows), following the trend in Figure \ref{fig:queryExecutionRecall} which shows the aggressive pruning that takes place as the queries become more specific.
Critically, this same effect is achieved for the object-object spatial search, where the recursive pruning of the search space quickly eliminates any candidates that are not viable matches to the pictorial query specification.
The location-object search does not show this effect because it counts the number of objects matching the query configuration and uses that to rank candidates, so no early stopping is done when the right object is found to the wrong cardinal direction of the location. %which iterates through the quadrants of each location and counts the number of objects matching the directional specification from the query,
%it does not stop early when a candidate does not match on an object, instead returning the count of matches to be used to rank all of the candidates.

%The worst case complexity is for a search of N object terms where every object category is mapped to every location L. In that case we have to do N lookups to pull N sets of size L and intersect them. Realistically this would not happen and some object classes would be very discriminative and we could intersect those first to be more efficient.



%To test the scalability of \emph{GESTALT} we test it over a \textit{region} densely covered with tags for objects and locations - the District of Columbia. 
%Aside from waiting for the download of photos from the flickr API and the use of YOLO on those photos, the construction of the DC dataset occurs within a few seconds. 
%We compare our methods of searching across our inverted index and two concept-map data structures and find that all are performant using the DC dataset, reporting detailed results in Figure \ref{figure:PerformanceExperiments}. 
%We can see that 3 query terms is ideal for a user seeking to prune their search space, and that our geospatial pattern matching using our Object-Object recursive grid search avoids the complexity of the more traditional sub-graph matching approach. 


%This is on the DC dataset
%This multiple-ownership situation is one of the driving requirements for implementing concept mapping to extract additional discriminatory information between locations based on the geospatial layout of objects.
%Spatial queries are the most computationally intensive aspect of the search.
%Object-Centric queries require a concept map that describes all n-ary object-object relations, where Location-Centric queries only need describe the set of binary object-location relations.
%These problems of searching by geographic sets of objects have previously been characterized as graph-matching problems. 
%As a graph-matching problem, the difference between a fully connected graph, and a hub-and-spoke graph is significant, particularly as the number of vertices increases. It quickly becomes intractable. \osullikomment{[CITE HERE]}
%We handle both these types of queries by focusing on pruning the search space down to a reasonable size before checking the spatial relationships between objects.

%The search problem must balance precision and recall while not being computationally intractable. An effective search process will use bloom filters to prune the search space for the more complicated geospatial search. Semantic enrichment should be applied independently at each stage of the search in an attempt to improve the recall of \textit{GESTALT}.

%\subsection{Last-mile Search Problem}
%First is a general idea of the region in which the location occurs. 
%Here region means the area surrounding a location. 
%For example, in searching for a winery, it is assumed that the searcher knows that they are in the swan valley region of Western Australia. 
%A region could be an administrative boundary like a city, suburb, or general geographic area. 
%Either way, we assume that the searcher can prune their search space to the commencement of the \textit{last-mile} search before using \textit{GESTALT}.
%The second assumes that the searcher knows a subset of the objects associated with a location. 
%They may or may not know any of the attributes of those objects (for example, material, color etc).

%\emph{GESTALT} is a last-mile search tool that assumes the user has a general idea of the location (region) that they wish to search. 

%Spatial search incorporates the concept of mapping and becomes a spatial search with a specific method depending on the objects' underlying data structure. 
%The general case is as follows: Given a set of locations with geospatial mappings of their child objects and a subset of those geospatial mappings of child objects which location does that subset match? 
%If using a graph structure, each location's objects become a graph where the objects are nodes and the geospatial relations are edges encoding the spatial relations (e.g. west of, north of). It is a subgraph matching problem, which is, of course, NP-Complete. 
%Alternately, representing each location's objects as a KD-Tree rooted on the centroid of the object cluster would allow for dynamic searching. For example, assuming an initial split on the longitude of objects, we could immediately tell that all objects in the left subtree would be west of that root. 
%For either of these geospatial approaches, a translation layer from the positional relational to cardinal relational will need to occur.

%Automating the labeling process is essential to scaling \textit{GESTALT} beyond a trivial size. 
%Options for automation are explored in detail in sections \ref{section:architecture} and \ref{section:related}, but essentially rely on combining remote sensing imagery, ground-based imagery and image metadata to generate mappings of objects to coordinates and parent locations.
%The ability to autonomously determine object locations will set the conditions for the remaining elements of GESTALT to scale.

%The search function has been implemented using the Python \textit{Pandas}\footnote{https://pypi.org/project/pandas/}{Pandas PyPI Repo} library. 
%This approach assumes a single data frame of objects and their determined locations because of the number of possible attributes an object can have and the relatively few that they possess, this is a sparse data structure. 
%The sparseness does indicate the discriminatory power of remembering attributes. For example, a 'door' is not informative, but a 'blue door' on your favorite seaside restaurant is more likely to prune the search space. 
%Because \textit{GESTALT} is designed only for the last-mile search and assumes a small starting region, it may remain feasible to use a simple data structure like a Pandas data frame containing all the objects for all the locations for the query region. 
%More work with the aggregation functions is required to determine if it can support all the necessary aggregation queries comparing object collections. 

%Semantic search has not been implemented. However, the Levenshtein string distance metric (with $threshold = 0.8$) checks for small spelling discrepancies in input words. The priority weights towards retrieving all possible objects, so we accept the increased risk of mistakenly including an object to move the recall closer to 100\%. The next component to be implemented is a nearest-neighbor retrieval mechanism using word embeddings. Prior work indicates that developing databases of embeddings is trivial\cite{Mueller2012}, but using existing datasets tools like word2vec, GloVe and fasttext can generate embeddings over large, publicly available corpora that can be recreated. 

%As discussed in the subsection on Ownership Assignment implementation, bloom filters are a much more efficient operator for set membership testing. 
%The KD-Tree is more suited for geospatial queries, so the Pandas Dataframe currently supports the gaps between the two in supporting aggregation queries. More work is required to integrate these data structures into a coherent search pipeline that maximizes recall while actively pruning the search space at every step so that the searcher can find their locations of interest. Natural language querying is an active area of research yet to present a solution capable of effectively translating natural language queries and their SQL solutions. Given the relatively constrained domain of this problem set, it is a good candidate for implementation as a low priority for improvement. 